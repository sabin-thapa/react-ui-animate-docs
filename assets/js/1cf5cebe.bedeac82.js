"use strict";(self.webpackChunkreact_ui_animate_docs=self.webpackChunkreact_ui_animate_docs||[]).push([[966],{3905:function(e,n,t){t.d(n,{Zo:function(){return m},kt:function(){return p}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var u=a.createContext({}),l=function(e){var n=a.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},m=function(e){var n=l(e.components);return a.createElement(u.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},c=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,u=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=l(t),p=o,f=c["".concat(u,".").concat(p)]||c[p]||d[p]||i;return t?a.createElement(f,r(r({ref:n},m),{},{components:t})):a.createElement(f,r({ref:n},m))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,r=new Array(i);r[0]=c;var s={};for(var u in n)hasOwnProperty.call(n,u)&&(s[u]=n[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var l=2;l<i;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}c.displayName="MDXCreateElement"},7456:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return u},default:function(){return p},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return d}});var a=t(7462),o=t(3366),i=(t(7294),t(3905)),r=["components"],s={sidebar_position:3,id:"animated-values",title:"Animated Values"},u=void 0,l={unversionedId:"animated-values",id:"animated-values",title:"Animated Values",description:"Due to time constraint, we couldn't complete this page. We will complete as soon as possible.",source:"@site/docs/animated-values.mdx",sourceDirName:".",slug:"/animated-values",permalink:"/docs/animated-values",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/animated-values.mdx",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,id:"animated-values",title:"Animated Values"},sidebar:"tutorialSidebar",previous:{title:"Getting Started",permalink:"/docs/getting-started"},next:{title:"Animations",permalink:"/docs/animations"}},m={},d=[{value:"Defining Animated Value",id:"defining-animated-value",level:2},{value:"Mounting and Unmounting Components",id:"mounting-and-unmounting-components",level:2}],c={toc:d};function p(e){var n=e.components,t=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Due to time constraint, we couldn't complete this page. We will complete as soon as possible."))),(0,i.kt)("p",null,"Animated Values are the fundamental concepts behind ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"react-ui-animate")),". They carry animated data, providing easy way to drive animations."),(0,i.kt)("h2",{id:"defining-animated-value"},"Defining Animated Value"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"useAnimatedValue")," is a hook that returns an object containing properties like: ",(0,i.kt)("inlineCode",{parentName:"p"},".value")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".currentValue"),". Animated Value objects serve as references to pieces of shared animation data that can be accessed and modified using their ",(0,i.kt)("inlineCode",{parentName:"p"},".value")," property. It is important to remember that ",(0,i.kt)("inlineCode",{parentName:"p"},".value")," property must be used to modify or to read data. ",(0,i.kt)("inlineCode",{parentName:"p"},"useAnimatedValue")," is similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"useRef"),", it also stores the data until the component is unmounted, does not lose data on other state changes and data modification is done without re-render."),(0,i.kt)("p",null,"In order to create an Animated Value, you should use ",(0,i.kt)("inlineCode",{parentName:"p"},"useAnimatedValue")," hook:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const animationNode = useAnimatedValue(initialValue);\n")),(0,i.kt)("p",null,"It returns a mutable object whose .value property is initialized to the passed argument initialValue. This can be any primitive like number or string."),(0,i.kt)("p",null,"In order to update Animated Value, you should set a new value of same primitive type onto the .value property. The modification is sponteneous which shows the instant reactiveness."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useAnimatedValue } from 'react-ui-animate';\n\nfunction SomeComponent() {\n  const animationNode = useAnimatedValue(0);\n\n  return (\n    <button onClick={() => (animationNode.value = Math.random())}>\n      Randomize\n    </button>\n  );\n}\n")),(0,i.kt)("p",null,"In the above example we update value from intial value 0 to random values. Updates are automatically animated smoothly. Lets see an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import { AnimatedBlock, useAnimatedValue } from 'react-ui-animate';\n\nexport default function () {\n  const opacity = useAnimatedValue(0); // It initializes opacity object with value 0.\n\n  return (\n    <div>\n      {/* AnimatedBlock component can read useAnimatedValue() */}\n      <AnimatedBlock\n        style={{\n          opacity: opacity.value, // using opacity with value property\n          width: 100,\n          padding: 20,\n          background: '#39F',\n        }}\n      >\n        ANIMATED\n      </AnimatedBlock>\n\n      {/* Assigning value to 1 auto animates from initialized value 0 to 1 smoothly */}\n      <button onClick={() => (opacity.value = 1)}>Animate Me</button>\n    </div>\n  );\n}\n")),(0,i.kt)("p",null,"In the above example when we click button, opacity is animated from 0 to 1 smoothly. As you can notice AnimatedBlock is used instead of any other HTML Element because the Animated Values cannot be read by HTML Elements, we need special type of Component that can read it. Here, we have AnimatedBlock HOC which is a div element and also can read Animated Values."),(0,i.kt)("h2",{id:"mounting-and-unmounting-components"},"Mounting and Unmounting Components"),(0,i.kt)("p",null,"Second most important aspect of Animated Value is that they provide a way to handle mounting and unmounting of any component. Generally, we use state to handle mounting and unmounting, but we don't have a proper way to make transitions between mounting as well as unmounting. React UI Animate provides useMountedValue hook to handle these scenarios."),(0,i.kt)("p",null,"To create Mounted Value, we use useMountedValue hook:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const mountedFunction = useMountedValue(boolean, {\n  from: number,\n  enter: number,\n  exit: number,\n});\n")),(0,i.kt)("p",null,"useMountedValue returns a function when a state and phases are passed as first and second arguments. The first argument must be a boolean state and second argument is an object with three phases property, from, enter and exit. The phases from, enter and exit are three numeric values which defines the transition lifecycle of a component when it mounts and unmounts."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useState } from 'react';\nimport { useMountedValue } from 'react-ui-animate';\n\nfunction SomeComponent() {\n  const [visible, setVisible] = useState(false);\n\n  const open = useMountedValue(visible, { from: 0, enter: 1, exit: 0 });\n\n  return (\n    <div>\n      <button onClick={() => setVisible((prev) => !prev)}>CLICK ME</button>\n    </div>\n  );\n}\n")),(0,i.kt)("p",null,"In the above example, by default the state is visible = false and the phases are {from: 0, enter: 1, exit: 0}. Now, lets use the mounted function open with a component."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-jsx"},"import { useState } from 'react';\nimport { useMountedValue } from 'react-ui-animate';\n\nfunction SomeComponent() {\n  const [visible, setVisible] = useState(false);\n\n  const open = useMountedValue(visible, { from: 0, enter: 1, exit: 0 });\n\n  return (\n    <div>\n      {open(\n        (animation, mounted) =>\n          mounted && (\n            <AnimatedBlock\n              style={{\n                width: 100,\n                height: 100,\n                backgroundColor: '#3399ff',\n                opacity: animation.value,\n              }}\n            />\n          )\n      )}\n\n      <button onClick={() => setVisible((prev) => !prev)}>CLICK ME</button>\n    </div>\n  );\n}\n")),(0,i.kt)("p",null,"In the above example, open function receives a callback that receives two arguments: the Animated Value and a boolean respectively. The first argument, Animated Value animates from from = 0 to enter = 1 when the visible is true and enter = 1 to exit = 0 when visible is false. And the second argument, boolean dinamically determines whether the component is mounted or not after animation. AnimatedBlock HOC is used to read animated values."))}p.isMDXComponent=!0}}]);